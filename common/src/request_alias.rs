use chrono::DateTime;
use chrono::Duration;
use chrono::Utc;
use common_macros::body;
use common_macros::response;

use crate::AccessRequestState;
use crate::CloudflareRole;
use crate::Schema;
use crate::UserAliases;

/// Operation on an access request
#[apply(Schema!)]
#[serde(rename_all = "snake_case")]
pub enum RequestOperation {
    /// Add an approval to a pending request
    Approve,
    /// Extend an active request by N minutes
    Extend(i32),
    /// Reject a pending request
    Reject,
    /// Cancel a pending request
    Cancel,
    /// Complete an active request
    Complete,
    /// Revoke permissions from an active request
    Revoke,
}

body! {
    #[Patch] RequestAlias -> RequestOperation
}

/// Record of a user interaction with an access request
#[apply(Schema!)]
pub struct UserInteraction {
    /// Interacting user's email address
    #[schema(example = "samira@cool-company.com")]
    pub user: String,
    /// User interaction timestamp
    pub timestamp: DateTime<Utc>,
}

/// Access request
#[apply(Schema!)]
pub struct Request {
    /// UUID generated by Satounki
    #[schema(example = "5da0230c-4eeb-4840-9ffa-d97f45a12182")]
    pub id: String,
    #[serde(skip)]
    pub company_id: i32,
    /// Human-friendly alias generated by Satounki
    #[schema(example = "samir-crazy-skyline-fish")]
    pub alias: String,
    /// Email address of the requester
    #[schema(example = "samir@cool-company.com")]
    pub requester: String,
    /// Service-specific username aliases of the requester
    pub requester_aliases: UserAliases,
    /// Number of approvals required
    #[schema(example = 1)]
    pub approvals_required: i32,
    /// Administrator approval requirement
    pub admin_approval_required: bool,
    /// Policy name
    #[schema(example = "compute_dns_admin")]
    pub policy: String,
    /// Access request timestamp
    pub timestamp: DateTime<Utc>,
    /// Reason for the request
    #[schema(example = "investigating issue #1234 impacting customer dns resolution")]
    pub justification: String,
    /// Duration of the request in minutes
    #[schema(example = 60)]
    pub minutes: i32,
    /// Amazon Web Services policy ARNs requested
    #[schema(example = json!(["arn:aws:iam::aws:policy/AmazonEC2FullAccess"]))]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub aws: Option<Vec<String>>,
    /// Amazon Web Services account to grant permissions on
    #[schema(example = "cool-company-production")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub aws_account: Option<String>,
    /// Cloudflare roles requested
    #[serde(skip_serializing_if = "Option::is_none")]
    #[schema(example = json!([CloudflareRole::Administrator]))]
    pub cloudflare: Option<Vec<CloudflareRole>>,
    /// Cloudflare account to grant permissions on
    #[schema(example = "cool-company.com")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub cloudflare_account: Option<String>,
    /// Google Cloud Platform roles requested
    #[serde(skip_serializing_if = "Option::is_none")]
    #[schema(example = json!(["roles/compute.admin"]))]
    pub gcp: Option<Vec<String>>,
    /// Google Cloud Platform project to grant permissions on
    #[schema(example = "cool-company-production")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub gcp_project: Option<String>,
    /// Approval status
    pub approved: bool,
    /// Current state in the access request lifecycle
    #[schema(example = AccessRequestState::Active)]
    pub state: AccessRequestState,
    /// Access request permissions expiry timestamp
    #[serde(skip_serializing_if = "Option::is_none")]
    pub access_expiry: Option<DateTime<Utc>>,
    /// Request approval records
    #[serde(skip_serializing_if = "Option::is_none")]
    pub approvals: Option<Vec<UserInteraction>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    /// Request extension records
    pub extensions: Option<Vec<UserInteraction>>,
    #[schema(example = None)]
    #[serde(skip_serializing_if = "Option::is_none")]
    /// Request rejection record
    pub rejection: Option<UserInteraction>,
    /// Request cancellation record
    #[schema(example = None)]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub cancellation: Option<UserInteraction>,
}

response! {
    #[Get] RequestAlias -> Request,
}

impl RequestAliasGetResponse {
    pub fn example() -> Self {
        Self(Request {
            id: "5da0230c-4eeb-4840-9ffa-d97f45a12182".to_string(),
            company_id: 0,
            alias: "samir-crazy-skyline-fish".to_string(),
            requester: "samir@cool-company.com".to_string(),
            requester_aliases: UserAliases {
                aws: Some("Samir".to_string()),
                cloudflare: None,
                gcp: None,
            },
            approvals_required: 1,
            admin_approval_required: true,
            policy: "compute_dns_admin".to_string(),
            timestamp: Utc::now(),
            justification: "to investigate incident #4321 impacting dns resolution".to_string(),
            minutes: 60,
            aws: Some(vec![
                "arn:aws:iam::aws:policy/AmazonEC2FullAccess".to_string()
            ]),
            aws_account: Some("cool-company-production".to_string()),
            cloudflare: Some(vec![CloudflareRole::Administrator]),
            cloudflare_account: Some("cool-company.com".to_string()),
            gcp: Some(vec!["roles/compute.admin".to_string()]),
            gcp_project: Some("cool-company-production".to_string()),
            approved: true,
            state: AccessRequestState::Active,
            access_expiry: Some(Utc::now() + Duration::minutes(60)),
            approvals: Some(vec![UserInteraction {
                user: "samira@cool-company.com".to_string(),
                timestamp: Utc::now() + Duration::minutes(1),
            }]),
            extensions: None,
            rejection: None,
            cancellation: None,
        })
    }
}
